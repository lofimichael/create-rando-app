#!/usr/bin/env node

import fs from "node:fs";
import path from "node:path";
import process from "node:process";

function printUsage() {
  console.log("create-rando-app <directory> [options]");
  console.log("");
  console.log("Options:");
  console.log("  --challenge <slug>     Challenge slug (default: starter-rando)");
  console.log("  --required <a,b,c>     Required dependency list (default: esbuild)");
  console.log("  --min-deps <n>         Minimum dependency count (default: 3)");
  console.log("  --force                Allow non-empty target directory");
  console.log("  --help                 Print usage");
}

function parseArgs(args) {
  const options = {
    challenge: "starter-rando",
    required: [ "esbuild" ],
    minDeps: 3,
    force: false,
    help: false
  };
  const positionals = [];

  for (let i = 0; i < args.length; i += 1) {
    const token = args[i];
    if (token === "--help" || token === "-h") {
      options.help = true;
      continue;
    }
    if (token === "--force") {
      options.force = true;
      continue;
    }
    if (token === "--challenge") {
      options.challenge = args[i + 1] || options.challenge;
      i += 1;
      continue;
    }
    if (token === "--required") {
      const raw = args[i + 1] || "";
      options.required = raw
        .split(",")
        .map((item) => item.trim())
        .filter(Boolean);
      i += 1;
      continue;
    }
    if (token === "--min-deps") {
      const parsed = Number.parseInt(args[i + 1] || "", 10);
      if (Number.isFinite(parsed) && parsed > 0) {
        options.minDeps = parsed;
      }
      i += 1;
      continue;
    }
    if (token.startsWith("-")) {
      throw new Error(`Unknown option: ${token}`);
    }

    positionals.push(token);
  }

  return { options, positionals };
}

function normalizePackageName(input) {
  return input
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, "-")
    .replace(/-+/g, "-")
    .replace(/^-|-$/g, "")
    .slice(0, 214) || "rando-app";
}

function writeFile(targetPath, content) {
  fs.mkdirSync(path.dirname(targetPath), { recursive: true });
  fs.writeFileSync(targetPath, content, "utf8");
}

function ensureDirectory(targetDir, force) {
  if (!fs.existsSync(targetDir)) {
    fs.mkdirSync(targetDir, { recursive: true });
    return;
  }

  const entries = fs.readdirSync(targetDir);
  if (entries.length > 0 && !force) {
    throw new Error(`Target directory is not empty: ${targetDir}. Use --force to continue.`);
  }
}

function buildPackageJson(packageName, requiredPackages) {
  const dependencyMap = Object.fromEntries(
    requiredPackages.map((dependency) => [ dependency, "latest" ])
  );

  return JSON.stringify({
    name: packageName,
    version: "0.1.0",
    private: true,
    type: "module",
    scripts: {
      dev: "node src/index.js",
      "validate:rando": "node scripts/verify-rando.js",
      test: "npm run validate:rando"
    },
    dependencies: dependencyMap
  }, null, 2) + "\n";
}

function buildDevRandoConfig(challengeSlug, requiredPackages, minDeps) {
  return JSON.stringify({
    challengeSlug,
    ecosystem: "npm",
    constraints: {
      requiredPackages,
      minDependencies: minDeps
    }
  }, null, 2) + "\n";
}

function buildValidatorScript() {
  return `import fs from "node:fs";

const config = JSON.parse(fs.readFileSync("devrando.config.json", "utf8"));
const packageJson = JSON.parse(fs.readFileSync("package.json", "utf8"));

const dependencies = {
  ...(packageJson.dependencies || {}),
  ...(packageJson.devDependencies || {})
};

const dependencyNames = Object.keys(dependencies);
const required = config.constraints?.requiredPackages || [];
const minDependencies = Number(config.constraints?.minDependencies || 1);

const missingRequired = required.filter((pkg) => !dependencyNames.includes(pkg));
const missingCount = dependencyNames.length < minDependencies;

if (missingRequired.length > 0) {
  console.error("Missing required packages:", missingRequired.join(", "));
  process.exit(1);
}

if (missingCount) {
  console.error(\`Need at least \${minDependencies} dependencies, found \${dependencyNames.length}.\`);
  process.exit(1);
}

console.log("Dev Rando validation passed.");
`;
}

function buildReadme(directoryName, challengeSlug) {
  return `# ${directoryName}

Generated by create-rando-app.

## Challenge

- Slug: \`${challengeSlug}\`

## Commands

- \`npm install\`
- \`npm run validate:rando\`
- \`npm run dev\`
`;
}

function buildEntryPoint() {
  return `console.log("Implement your Dev Rando solution here.");\n`;
}

function run() {
  const parsed = parseArgs(process.argv.slice(2));
  const { options, positionals } = parsed;
  if (options.help) {
    printUsage();
    return;
  }

  const directoryName = positionals[0] || "rando-app";
  const targetDir = path.resolve(process.cwd(), directoryName);
  const packageName = normalizePackageName(path.basename(targetDir));
  const requiredPackages = options.required.length > 0 ? options.required : [ "esbuild" ];

  ensureDirectory(targetDir, options.force);

  writeFile(path.join(targetDir, "package.json"), buildPackageJson(packageName, requiredPackages));
  writeFile(
    path.join(targetDir, "devrando.config.json"),
    buildDevRandoConfig(options.challenge, requiredPackages, options.minDeps)
  );
  writeFile(path.join(targetDir, "scripts/verify-rando.js"), buildValidatorScript());
  writeFile(path.join(targetDir, "src/index.js"), buildEntryPoint());
  writeFile(path.join(targetDir, ".gitignore"), "node_modules\n.DS_Store\n");
  writeFile(path.join(targetDir, "README.md"), buildReadme(path.basename(targetDir), options.challenge));

  console.log(`Scaffolded Dev Rando project at: ${targetDir}`);
  console.log("Next steps:");
  console.log(`1) cd ${path.basename(targetDir)}`);
  console.log("2) npm install");
  console.log("3) npm run validate:rando");
  console.log("4) npm run dev");
}

try {
  run();
} catch (error) {
  console.error(`create-rando-app failed: ${error.message}`);
  process.exit(1);
}
